#!/usr/bin/python

import subprocess
import sys

possible_masters = [ 'develop', 'master', 'main' ]


def git_output(args):
    result = subprocess.run(['git', *args], stdout=subprocess.PIPE)
    return result.stdout.decode('utf-8')

def get_master_branch():
    for branch in git_output(['branch', '--list']).splitlines():
        branch = branch.strip()
        if branch in possible_masters:
            return branch

    return 'master'

def branch_exists(branch_name):
    for branch in git_output(['branch', '--list', '--remote']).splitlines():
        branch = branch.strip()
        if not branch.startswith('origin/'): continue
        if branch == f'origin/{branch_name}': return True
    return False

def get_merged_branches(master_branch):
    output = git_output([
        'for-each-ref',
        '--merged',
        f'origin/{master_branch}',
        '--format',
        '%(refname:short)',
        'refs/heads'])
    branches = output.split('\n')

    for branch in branches:
        if not branch:
            continue

        # Don't delete master branch.
        if branch == master_branch:
            continue

        yield branch

def delete_branch(branch):
    git_output(['branch', '-D', branch])
    
def run(dry_run=True):
    merged_branches = set()

    for branch in possible_masters:
        if not branch_exists(branch): continue

        print("Checking", branch)
        merged_branches.update(get_merged_branches(branch))

    for branch in merged_branches:
        if not dry_run:
            delete_branch(branch)
        print(f'Deleted {branch}')

    if dry_run:
        print('This was a dry run. Use --force or -F to actually delete branches')

def should_actually_delete():
    return '--force' in sys.argv or '-F' in sys.argv

if __name__ == "__main__":
    dry_run = not should_actually_delete()
    run(dry_run)